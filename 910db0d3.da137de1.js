(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{112:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return b})),r.d(t,"metadata",(function(){return o})),r.d(t,"rightToc",(function(){return c})),r.d(t,"default",(function(){return l}));var a=r(2),n=r(6),i=(r(0),r(125)),b={id:"Arrow",title:"Arrow",sidebar_label:"Arrow"},o={id:"Arrow",title:"Arrow",description:"It should be noted that Arrows are not currently stack safe, I am working on a stack safe implementation",source:"@site/docs/Arrow.md",permalink:"/light-arrow-docs/docs/Arrow",editUrl:"https://github.com/lauri3new/light-arrow-docs/tree/master/docs/Arrow.md",sidebar_label:"Arrow",sidebar:"someSidebar",previous:{title:"TaskEither",permalink:"/light-arrow-docs/docs/TaskEither"},next:{title:"Either",permalink:"/light-arrow-docs/docs/Either"}},c=[],d={rightToc:c};function l(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,r,{components:t,mdxType:"MDXLayout"}),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"It should be noted that Arrows are not currently stack safe, I am working on a stack safe implementation"))),Object(i.b)("p",null,"Arrows are data structures that describe asynchronous operations that can succeed with a value A or fail with a value E that depends on some input context Ctx. Arrows won't actually perform any operation until the run method is called, this means that Arrows have the nice property of being referentially transparent. By delaying execution until the run method is called, Arrows provide a way to perform dependency injection as we can group all the dependencies of the program into a single object type and provide test and production implementations of these in the run method as we wish, see the example below."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface Arrow<Ctx, E, A> {\n  __val: (_:Ctx) => Promise<Either<E, A>>\n  map: <B>(f: (_:A) => B) => Arrow<Ctx, E, B>\n  leftMap: <E2>(f: (_:E) => E2) => Arrow<Ctx, E2, A>\n  biMap: <E2, B>(f: (_:E) => E2, g: (_:A) => B) => Arrow<Ctx, E2, B>\n  flatMap: <E2, B>(f: (_:A) => Arrow<Ctx, E | E2, B>) => Arrow<Ctx, E | E2, B>\n  flatMapF: <E2, B>(f: (_:A) => (_:Ctx) => Promise<Either<E2, B>>) => Arrow<Ctx, E | E2, B>\n  andThen: <E2, B>(_: Arrow<A, E2, B>) => Arrow<Ctx, E | E2, B>\n  andThenF: <E2, B>(f: (_:A) => Promise<Either<E2, B>>) => Arrow<Ctx, E | E2, B>\n  andThenMerge: <E2, B>(_: Arrow<A, E2, B>) => Arrow<Ctx, E | E2, A & B>\n  combine: (f:Arrow<Ctx, E, A>) => Arrow<Ctx, E, A>\n  runP: (\n    context: Ctx\n  ) => Promise<A>\n  run: <B, E2, ER>(\n    context: Ctx,\n    f: (_:A) => B,\n    g: (_:E) => E2,\n    j: (_?: Error) => ER\n  ) => Promise<B | E2 | ER>\n}\n")),Object(i.b)("p",null,"Example usage"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"\ninterface hasDb {\n  db: db\n}\n\ninterface hasEmailService {\n  emailService: {\n    send: Promise<string>\n  }\n}\n\ninterface userService: {\n  getById: <A extends hasDb>(id: number) => Arrow<A, string, User>\n  getFriendsOf: <A extends hasDb>(email: string) => Arrow<A, string, User[]>\n  emailInvite: <A extends hasDb & hasEmailService>(emails: string[]) => Arrow<A, string, string>\n}\n\nconst inviteFriendsOfUser = (id: number) => userService.getById(id)\n  .flatMap((user) => userService.getFriendsOf(user.email))\n  .flatMap((usersEmails) => userService.emailInvite(usersEmails))\n\nconst inviteFriendsOfUsers = sequence([\n  inviteFriendsOfUser(1),\n  inviteFriendsOfUser(5),\n  inviteFriendsOfUser(7)\n])\n// no side effects performed yet, we have just described what we are going to do\n\n// we can now run our program at our leisure with test or production implementations of our dependencies\n// test\ninviteFriendsOfUsers\n  .runP({\n    db: mockDb,\n    emailService: mockEmailService\n  })\n\n// production\ninviteFriendsOfUsers\n  .runP({ db, emailService })\n\n")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Interface"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"Arrow<Ctx, E, A>")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Arrows are data types that describe asynchronous operations that can succeed with a value A or fail with a value E that require some dependencies S.")))),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Functions"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Type"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Arrow"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"Arrow<Ctx, E, A>((_:Ctx) => Promise<Either<E, A>>): Arrow<Ctx, E, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"resolve"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A>(a: A):Arrow<any, never, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"reject"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A>(a: A):Arrow<any, A, never>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"ofContext"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A>():Arrow<A, never, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"fromPromise"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A, E, C = any>(a: Promise<A>):Arrow<C, E, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"fromFailablePromise"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A, E, C = any>(a: Promise<A>):Arrow<C, E, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"fromEither"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<E, A, C = any>(a:Either<E, A>):Arrow<C, E, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"fromPEither"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<E, A, C = any>(a:Promise<Either<E, A>>):Arrow<C, E, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"fromKP"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<Ctx, A>(a:(_:Ctx) => Promise<A>):Arrow<Ctx, never, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"fromFailableKP"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<Ctx, E, A>(a:(_:Ctx) => Promise<A>):Arrow<Ctx, E, A>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"sequence"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A, B, C>(as: Arrow<A, B, C>[]): Arrow<A, B, C[]>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"combine"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"<A, B, C>(...as: Arrow<A, B, C>[]): Arrow<A, B, C>"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"retry"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(i.b)("inlineCode",{parentName:"td"},"(n: number) => <A, B, C>(a: Arrow<A, B, C>): Arrow<A, B, C>"))))))}l.isMDXComponent=!0}}]);