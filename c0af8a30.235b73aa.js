(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return c}));var a=n(2),r=n(6),p=(n(0),n(89)),o={id:"HttpApp",title:"HttpApp",sidebar_label:"HttpApp"},s={unversionedId:"HttpApp",id:"HttpApp",isDocsHomePage:!1,title:"HttpApp",description:"Light-arrow provides bindings for writing type safe http apps. Instead of using native response methods we can instead describe the http response using a Result data type.",source:"@site/docs/HttpApp.md",slug:"/HttpApp",permalink:"/light-arrow-docs/docs/HttpApp",editUrl:"https://github.com/lauri3new/light-arrow-docs/tree/master/docs/HttpApp.md",version:"current",sidebar_label:"HttpApp",sidebar:"someSidebar",previous:{title:"Either",permalink:"/light-arrow-docs/docs/Either"},next:{title:"Result",permalink:"/light-arrow-docs/docs/Result"}},b=[],i={rightToc:b};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(p.b)("wrapper",Object(a.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(p.b)("p",null,"Light-arrow provides bindings for writing type safe http apps. Instead of using native response methods we can instead describe the http response using a ",Object(p.b)("a",Object(a.a)({parentName:"p"},{href:"/light-arrow-docs/docs/Result"}),"Result data type"),"."),Object(p.b)("p",null,"An HttpApp is simply a ",Object(p.b)("inlineCode",{parentName:"p"},"(ctx: Context) => Promise<Result>"),". To help with type safety and composability we can define HttpRoutes as ",Object(p.b)("inlineCode",{parentName:"p"},"Arrow<Context, notFound | Result, Result>")," and then use the seal function, providing handlers for 'not found' and exception cases. We can then bind an HttpApp to an express instance using the bindApp function, providing any dependencies the Arrows require at that time if we want."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface Context {\n  req: Request\n}\n")),Object(p.b)("p",null,"We can express our whole express app using Arrows. Middlewares can be defined as ",Object(p.b)("inlineCode",{parentName:"p"},"Arrow<A, Result, B>")," where A and B extend the context. Multiple middlewares can be stacked together in a type safe manner using the ",Object(p.b)("inlineCode",{parentName:"p"},"andThen")," function. By defining our middleware this way we can expand and transform the context in a composable and type safe way, for example attaching services or authorisation data to the context."),Object(p.b)("p",null,Object(p.b)("strong",{parentName:"p"},"An example Middleware")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const authorizationMiddleware: Arrow<Context, Result, {\n  loggedIn: boolean;\n  req: Request;\n}> = draw((ctx: Context) => {\n  if (ctx.req.headers.authorization) {\n    return succeed({ ...ctx, loggedIn: true })\n  } else {\n    return fail(Unauthorised({}))\n  }\n})\n")),Object(p.b)("p",null,"Handlers can be written as ",Object(p.b)("inlineCode",{parentName:"p"},"Arrow<A, Result, Result>")," where A is inferred from the middlewares. HttpRoutes are then Arrows of Type ",Object(p.b)("inlineCode",{parentName:"p"},"Arrow<A, notFound \\ Result, Result>"),", and we can combine HttpRoutes together (similar to how we would use an express Router) using the orElse function."),Object(p.b)("p",null,Object(p.b)("strong",{parentName:"p"},"An example HttpRoute")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const getUsers: Arrow<{\n  loggedIn: boolean;\n  req: Request;\n}, NotFound, Result> = get('/users')\n  .andThen(draw((ctx: Context) => ctx.services.getUsers()))\n")),Object(p.b)("p",null,Object(p.b)("strong",{parentName:"p"},"Multiple routes and middlewares combined")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const routes: Arrow<Context, NotFound | Result, Result> = orElse(\n  get('/healthcheck').map(() => OK({})),\n  authorizationMiddleware.andThen(\n    orElse(\n      getUsers,\n      getTimeline\n    )\n  )\n)\n")),Object(p.b)("p",null,Object(p.b)("strong",{parentName:"p"},"Converting HttpRoutes to an HttpApp")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const httpApp = seal(\n  routes,\n  () => NotFound({\n    message: 'not found'\n  }),\n  () => InternalServerError({\n    message: 'oops something went wrong'\n  })\n)\n")),Object(p.b)("p",null,Object(p.b)("strong",{parentName:"p"},"Binding our HttpApp to an express instance")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const expressInstance = express()\nconst { app } = bindApp(httpApp)(expressInstance)\n\napp.listen(8080)\n")),Object(p.b)("p",null,"Once we have all the routes described we can convert the HttpRoutes to an HttpApp using the seal function, providing functions for converting the notFound type and runtime exceptions into http Results. We can then use the bindApp function to attach our httpApp to an express application instance and inject dependencies."),Object(p.b)("table",null,Object(p.b)("thead",{parentName:"table"},Object(p.b)("tr",{parentName:"thead"},Object(p.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Names (types)"),Object(p.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Type"),Object(p.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(p.b)("tbody",{parentName:"table"},Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"<Context>")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"{ req: Request }")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Context of a request, we can add properties into the context.")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"NotFound")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"{ path: string, method: string }")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"NotFound returned from a filter Arrow (get, post, patch, put, del, options) as the failure case.")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"HttpMethods")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"enum of http methods")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"http methods GET \\ POST \\ PATCH \\ PUT \\ DELETE \\ OPTIONS")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"HttpRoutes")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"<A extends Context = Context> = Arrow<A, NotFound\\Result, Result> \\ Arrow<A, NotFound, Result>")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"Arrows that returns a http Result that is translated into an response or fails with a NotFound.")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"HttpApp")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),Object(p.b)("inlineCode",{parentName:"td"},"<A extends Context = Context> = (ctx: A) => Promise<Result>")),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"HttpApps are made by 'sealing' HttpRoutes using the seal functions, where handlers for NotFound and exceptions are added.")))),Object(p.b)("table",null,Object(p.b)("thead",{parentName:"table"},Object(p.b)("tr",{parentName:"thead"},Object(p.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Functions"),Object(p.b)("th",Object(a.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(p.b)("tbody",{parentName:"table"},Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"get, post, patch, put, del, options"),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"functions that return an Arrow that will filter the matching of an incoming request by method and a supplied path string, returning an Arrow of type ",Object(p.b)("inlineCode",{parentName:"td"},"Arrow<A, notFound, A & { params: B }>")," where A extends Context")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"bindApp"),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"used to attach the http app to an express app instance")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"seal"),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"converts HttpRoutes into an HttpApp by providing handlers for NotFound and exceptions are added")),Object(p.b)("tr",{parentName:"tbody"},Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"runResponse"),Object(p.b)("td",Object(a.a)({parentName:"tr"},{align:"left"}),"an internal function used by bindApp ",Object(p.b)("inlineCode",{parentName:"td"},"runResponse(res: Response, result: Result): void")," that translates a result into an http response using the express response object")))))}c.isMDXComponent=!0}}]);